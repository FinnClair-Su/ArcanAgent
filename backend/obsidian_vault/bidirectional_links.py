"""
Bidirectional Links System
Manages [[wiki-style]] links between markdown notes
"""

import re
import logging
from typing import Dict, List, Set, Tuple, Optional
from collections import defaultdict


logger = logging.getLogger(__name__)


class BidirectionalLinks:
    """Manages bidirectional links between notes"""
    
    def __init__(self):
        # Forward links: source_id -> set(target_ids)
        self.outgoing_links: Dict[str, Set[str]] = defaultdict(set)
        
        # Backward links: target_id -> set(source_ids) 
        self.incoming_links: Dict[str, Set[str]] = defaultdict(set)
        
        # Link aliases: note_id -> {alias -> original_title}
        self.link_aliases: Dict[str, Dict[str, str]] = defaultdict(dict)
        
        # Title to file_id mapping for link resolution
        self.title_to_id: Dict[str, str] = {}
        
        # Link patterns for parsing
        self.link_pattern = re.compile(r'\[\[([^\]]+)\]\]')
        self.alias_pattern = re.compile(r'\[\[([^|]+)\|([^\]]+)\]\]')
    
    def set_title_mapping(self, title_to_id: Dict[str, str]):
        """Set title to file_id mapping for link resolution"""
        self.title_to_id = title_to_id
    
    async def extract_links_from_content(self, content: str) -> List[Tuple[str, str, bool]]:
        \"\"\"Extract all links from markdown content\n        Returns: List of (target_title, display_text, is_alias)\n        \"\"\"\n        \n        links = []\n        \n        # Find all [[...]] patterns\n        for match in self.link_pattern.finditer(content):\n            link_content = match.group(1)\n            \n            # Check if it's an alias link\n            alias_match = self.alias_pattern.match(match.group(0))\n            if alias_match:\n                target_title = alias_match.group(1).strip()\n                display_text = alias_match.group(2).strip()\n                links.append((target_title, display_text, True))\n            else:\n                target_title = link_content.strip()\n                links.append((target_title, target_title, False))\n        \n        return links\n    \n    async def resolve_link_targets(self, links: List[Tuple[str, str, bool]]) -> List[str]:\n        \"\"\"Resolve link titles to file IDs\"\"\"\n        \n        resolved_ids = []\n        \n        for target_title, display_text, is_alias in links:\n            # Try exact match first\n            target_id = self.title_to_id.get(target_title.lower())\n            \n            if target_id:\n                resolved_ids.append(target_id)\n                \n                # Store alias if applicable\n                if is_alias and target_id not in self.link_aliases:\n                    self.link_aliases[target_id][display_text] = target_title\n            else:\n                # Log unresolved link\n                logger.debug(f\"Unresolved link: {target_title}\")\n        \n        return resolved_ids\n    \n    async def add_links(self, source_id: str, target_ids: List[str]):\n        \"\"\"Add outgoing links from source to targets\"\"\"\n        \n        # Clear existing outgoing links for this source\n        await self.remove_outgoing_links(source_id)\n        \n        # Add new links\n        for target_id in target_ids:\n            if target_id != source_id:  # Avoid self-links\n                self.outgoing_links[source_id].add(target_id)\n                self.incoming_links[target_id].add(source_id)\n        \n        logger.debug(f\"Added {len(target_ids)} links from {source_id}\")\n    \n    async def remove_outgoing_links(self, source_id: str):\n        \"\"\"Remove all outgoing links from a source note\"\"\"\n        \n        if source_id in self.outgoing_links:\n            # Remove incoming references\n            for target_id in self.outgoing_links[source_id]:\n                self.incoming_links[target_id].discard(source_id)\n                \n                # Clean up empty sets\n                if not self.incoming_links[target_id]:\n                    del self.incoming_links[target_id]\n            \n            # Remove outgoing links\n            del self.outgoing_links[source_id]\n    \n    async def remove_note_links(self, note_id: str):\n        \"\"\"Remove all links involving a note (both incoming and outgoing)\"\"\"\n        \n        # Remove outgoing links\n        await self.remove_outgoing_links(note_id)\n        \n        # Remove incoming links\n        if note_id in self.incoming_links:\n            for source_id in self.incoming_links[note_id]:\n                self.outgoing_links[source_id].discard(note_id)\n                \n                # Clean up empty sets\n                if not self.outgoing_links[source_id]:\n                    del self.outgoing_links[source_id]\n            \n            del self.incoming_links[note_id]\n        \n        # Remove aliases\n        if note_id in self.link_aliases:\n            del self.link_aliases[note_id]\n    \n    async def update_note_links(self, note_id: str, content: str):\n        \"\"\"Update links for a note based on its content\"\"\"\n        \n        # Extract links from content\n        links = await self.extract_links_from_content(content)\n        \n        # Resolve to file IDs\n        target_ids = await self.resolve_link_targets(links)\n        \n        # Update links\n        await self.add_links(note_id, target_ids)\n    \n    def get_outgoing_links(self, note_id: str) -> Set[str]:\n        \"\"\"Get all outgoing links from a note\"\"\"\n        return self.outgoing_links.get(note_id, set())\n    \n    def get_incoming_links(self, note_id: str) -> Set[str]:\n        \"\"\"Get all incoming links to a note\"\"\"\n        return self.incoming_links.get(note_id, set())\n    \n    def get_link_density(self, note_id: str) -> float:\n        \"\"\"Calculate link density for a note\"\"\"\n        outgoing = len(self.get_outgoing_links(note_id))\n        incoming = len(self.get_incoming_links(note_id))\n        total_notes = len(self.title_to_id)\n        \n        if total_notes <= 1:\n            return 0.0\n        \n        # Density = (in + out) / (max_possible_connections)\n        max_connections = (total_notes - 1) * 2  # Can link to all others both ways\n        density = (incoming + outgoing) / max_connections\n        \n        return min(density, 1.0)\n    \n    async def find_broken_links(self) -> Dict[str, List[str]]:\n        \"\"\"Find links that point to non-existent notes\"\"\"\n        \n        broken_links = defaultdict(list)\n        valid_ids = set(self.title_to_id.values())\n        \n        for source_id, target_ids in self.outgoing_links.items():\n            for target_id in target_ids:\n                if target_id not in valid_ids:\n                    broken_links[source_id].append(target_id)\n        \n        return dict(broken_links)\n    \n    async def suggest_links(self, note_id: str, content: str, limit: int = 5) -> List[str]:\n        \"\"\"Suggest potential links based on content analysis\"\"\"\n        \n        suggestions = []\n        content_lower = content.lower()\n        \n        # Find titles mentioned in content but not linked\n        current_links = self.get_outgoing_links(note_id)\n        \n        for title, target_id in self.title_to_id.items():\n            if (target_id != note_id and \n                target_id not in current_links and \n                title in content_lower):\n                suggestions.append(target_id)\n        \n        return suggestions[:limit]\n    \n    async def get_orphan_notes(self) -> List[str]:\n        \"\"\"Find notes with no incoming or outgoing links\"\"\"\n        \n        all_note_ids = set(self.title_to_id.values())\n        linked_notes = set(self.outgoing_links.keys()) | set(self.incoming_links.keys())\n        \n        return list(all_note_ids - linked_notes)\n    \n    async def get_hub_notes(self, min_connections: int = 5) -> List[Tuple[str, int]]:\n        \"\"\"Find notes with many connections (potential hub notes)\"\"\"\n        \n        hubs = []\n        \n        for note_id in set(self.outgoing_links.keys()) | set(self.incoming_links.keys()):\n            total_connections = (\n                len(self.get_outgoing_links(note_id)) + \n                len(self.get_incoming_links(note_id))\n            )\n            \n            if total_connections >= min_connections:\n                hubs.append((note_id, total_connections))\n        \n        # Sort by connection count\n        hubs.sort(key=lambda x: x[1], reverse=True)\n        \n        return hubs\n    \n    async def get_link_statistics(self) -> Dict[str, any]:\n        \"\"\"Get comprehensive link statistics\"\"\"\n        \n        total_notes = len(self.title_to_id)\n        total_outgoing = sum(len(targets) for targets in self.outgoing_links.values())\n        total_incoming = sum(len(sources) for sources in self.incoming_links.values())\n        \n        # Should be equal\n        assert total_outgoing == total_incoming\n        \n        orphans = await self.get_orphan_notes()\n        hubs = await self.get_hub_notes()\n        broken = await self.find_broken_links()\n        \n        return {\n            \"total_notes\": total_notes,\n            \"total_links\": total_outgoing,\n            \"average_links_per_note\": total_outgoing / max(total_notes, 1),\n            \"orphan_notes\": len(orphans),\n            \"hub_notes\": len(hubs),\n            \"broken_links\": sum(len(links) for links in broken.values()),\n            \"link_density\": total_outgoing / max((total_notes * (total_notes - 1)), 1)\n        }\n    \n    async def create_link_in_content(self, content: str, target_title: str, alias: str = None) -> str:\n        \"\"\"Add a new link to existing content\"\"\"\n        \n        if alias:\n            link_text = f\"[[{target_title}|{alias}]]\"\n        else:\n            link_text = f\"[[{target_title}]]\"\n        \n        # Simple insertion at the end for now\n        # In practice, you'd want smarter insertion logic\n        if not content.strip():\n            return link_text\n        else:\n            return content + f\" {link_text}\"\n    \n    async def remove_link_from_content(self, content: str, target_title: str) -> str:\n        \"\"\"Remove a specific link from content\"\"\"\n        \n        # Remove both regular and alias links\n        patterns = [\n            f\"\\[\\[{re.escape(target_title)}\\]\\]\",\n            f\"\\[\\[{re.escape(target_title)}\\|[^\\]]+\\]\\]\"\n        ]\n        \n        for pattern in patterns:\n            content = re.sub(pattern, \"\", content)\n        \n        # Clean up extra whitespace\n        content = re.sub(r'\\s+', ' ', content).strip()\n        \n        return content"